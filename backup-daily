#!/bin/bash
#backup-daily is released under the General Public License.
#Copyright (C) 2010-2012 Shezaan Topiwala
#This file is part of "Rabia Backups".

#backup-daily is free software: you can redistribute it and or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#backup-daily is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with backup-daily.  If not, see <http://www.gnu.org/licenses/>.

### This script is called by "run-backup-daily" ###
. backup-headers

EXCLUDE_FILE="$LOG_DIR/backup-excludes-daily"
INCLUDE_FILE="$LOG_DIR/backup-includes-daily"
BACKUP_MAIL="$LOG_DIR/backup-mail-daily"
DISK_STATUS="$LOG_DIR/disk-report-daily"
RSYNC='rsync -avR --delete --stats'

####### DO NOT EDIT BELOW THIS LINE #######

mkdir -pm 0744 $LOG_DIR

while getopts "t:c:l:u:" options
    do
        case $options in
            t) 
                BASE_BACKUP_DIR="$OPTARG" # This is the default if a directory is not specified in the config file.
                ;;
            c) 
                BACKUP_CONFIG="$OPTARG"
                ;;
            l)
                BACKUP_LOG="$OPTARG"
                ;;
            u)
                BACKUP_USER="$OPTARG" # This is the default user if a user is not specified in the config file.
                ;;
            --) 
                shift
                break;;
        esac
    done

TODAY=`date +%F`
DESTINATION=""
OVERIDE_USER=""

# Parse out the config file.
parse_config() {
    while read line
        do  
            local LOCATION=`echo $line | awk -F":" '{ print $1 }'`
            SERVER=`echo $line | awk -F":" '{ print $2 }'`
            local INCLUDES=`echo $line | awk -F":" '{ print $3 }' | tr "," "\n" > $INCLUDE_FILE`
            local EXCLUDES=`echo $line | awk -F":" '{ print $4 }' | tr "," "\n" > $EXCLUDE_FILE`
            local RETENTION=`echo $line | awk -F":" '{ print $5 }'`
            local TARGET=`echo $line | awk -F":" '{ print $6 }'`
            local USER=`echo $line | awk -F":" '{ print $7 }'`
            INTERVAL=`echo $line | awk -F":" '{ print $8 }'`

            if [[ -z $TARGET && -n $BASE_BACKUP_DIR ]]; then
                echo -e "=== START OF BACKUPS FOR $SERVER ===\n"
                echo "*** BACKUPS FOR $SERVER STARTED `date` ***"
                echo "Only default location specified: Priority set to Default $BASE_BACKUP_DIR"
                DESTINATION=$BASE_BACKUP_DIR
            fi

            if [[ -n $TARGET && -z $BASE_BACKUP_DIR ]]; then
                echo -e "=== START OF BACKUPS FOR $SERVER ===\n"
                echo "*** BACKUPS FOR $SERVER STARTED `date` ***"
                echo "Only target location specified: Priority set to Target $TARGET"
                DESTINATION=$TARGET
            fi

            if [[ -n $TARGET && -n $BASE_BACKUP_DIR ]]; then
                echo -e "=== START OF BACKUPS FOR $SERVER ===\n"
                echo "*** BACKUPS FOR $SERVER STARTED `date` ***"
                echo "Both locations specified: Priority set to Target $TARGET"
                DESTINATION=$TARGET
            fi

            if [[ -z $TARGET && -z $BASE_BACKUP_DIR ]]; then
                echo -e "=== START OF BACKUPS FOR $SERVER ===\n"
                echo "*** BACKUPS FOR $SERVER STARTED `date` ***"
                echo "You have neither provided a default directory as specified by the -t flag, nor have you specified a backup directory as specified by the 6th column in your config file."
            fi

            if [[ -z $USER && -n $BACKUP_USER ]]; then
                echo "Only default user specified: Priority to Default user $BACKUP_USER"
                OVERIDE_USER=$BACKUP_USER
            fi

            if [[ -n $USER && -z $BACKUP_USER ]]; then
                echo "Only overiding user specified: Priority to use Overide user $USER"
                OVERIDE_USER=$USER
            fi

            if [[ -n $USER && -n $BACKUP_USER ]]; then
                echo "Both users specified: Priority to use Overide user $USER"
                OVERIDE_USER=$USER
            fi

            if [[ -z $USER && -z $BACKUP_USER ]]; then
                echo "You have neither provided a default user as specified by the -u flag, nor have you specified an overiding user as specified by the 7th column in your config file."
            fi

            disk_space_check
            delete_old $RETENTION $SERVER
            if [ "$LOCATION" == "remote" ] ; then
                backup_remote $SERVER
            else
                backup_local $SERVER
            fi
            copy_to_today $SERVER
            echo "*** BACKUPS FOR $SERVER ENDED `date` ***"
            echo -e "=== END OF BACKUPS FOR $SERVER ===\n"
        done < $BACKUP_CONFIG_DAILY
}

### Deletion happens on the destination server.###
# This routine also excludes files and directories in the count
# that don't follow the YYYY-MM-DD format
delete_old() {
    # First count number of directories.
    local server=$2
    local directory="$DESTINATION/$server"
    local count=0
    declare -a filestack
    for stuff in `ls -1 $directory`; do
        local yyyy=`echo $stuff | cut -d '-' -f1`
        local yyyy_len=`echo ${#yyyy}`
        isNumber $yyyy
        local yyyy_result=$myresult

        local mm=`echo $stuff | cut -d '-' -f2`
        local mm_len=`echo ${#mm}`
        isNumber $mm
        local mm_result=$myresult

        local dd=`echo $stuff | cut -d '-' -f3`
        local dd_len=`echo ${#dd}`
        isNumber $dd
        local dd_result=$myresult

        if [[ $yyyy_result -eq 0 || $mm_result -eq 0 || $dd_result -eq 0 || -z $yyyy || -z $mm || -z $dd || "$yyyy_len" -ne 4 || "$mm_len" -ne 2 || "$dd_len" -ne 2 ]]; then
            echo -n ""
        else
            count=$[$count+1]
            filestack=( "${filestack[@]}" "$stuff" )
        fi
    done

    echo "Filestack: ${filestack[@]}"
    echo "Files: $count"

    local delete_num=""
    if [ "$count" -eq "$1" ]; then
        # First check to see if this is a rerun on the same day
        local stack_length=${#filestack[@]}
        local last_element=${filestack[$stack_length-1]}
        if [ $TODAY == $last_element ]; then
            echo "Backup of this name already exists" #Displays only when $RETENTION reached.
            delete_num=0
        else
            delete_num=$[$count-$1+1]
            echo "Files to delete, count match: $delete_num"
        fi
    elif [ "$count" -gt "$1" ]; then
        delete_num=$[$count-$1+1]
        echo "Files to delete, count greater: $delete_num"
    else
        delete_num=0
        echo "Nothing to delete: $delete_num"
    fi
        cd $DESTINATION/$server/
        local mystack=`echo ${filestack[@]} | sort | tr " " "\n" | head -n$delete_num | xargs -d '\n' rm -rf`
}

copy_to_today() {
    local server=$1
    local CURRENT="$DESTINATION/$server/daily/current"
    mkdir -p $DESTINATION/$server/daily/$TODAY
    cp -al $CURRENT/* $DESTINATION/$server/daily/$TODAY
}

###Auto connect with SSH keys###
backup_remote() {
    local server=$1
    local CURRENT="$DESTINATION/$server/daily/current"
    mkdir -p $DESTINATION/$server/daily
    cd $DESTINATION/$server/daily
    local connection="-e ssh $OVERIDE_USER@$server:"
    while read line
        do
            $RSYNC --exclude-from=$EXCLUDE_FILE $connection$line $CURRENT
        done < $INCLUDE_FILE
}

backup_local() {
    local server=$1
    local CURRENT="$DESTINATION/$server/daily/current"
    mkdir -p $DESTINATION/$server/daily
    cd $DESTINATION/$server/daily
    while read line
        do
            $RSYNC --exclude-from=$EXCLUDE_FILE $line $CURRENT
        done < $INCLUDE_FILE
}

disk_space_check() {
    echo "Destination $DESTINATION"
    df -hP $DESTINATION > $DISK_STATUS
    usep=`cat $DISK_STATUS | awk '{ print $5 }' | grep -v ^Use | tr -d %`
    partition=`cat $DISK_STATUS | awk '{ print $1}' | grep -v ^Filesystem`
    if [[ $usep -ge $DISK_SPACE_ALERT ]]; then
        echo "Running out of space \"$partition ($usep%)\" on $(hostname) as of $(date)" > $BACKUP_MAIL
        echo "Since threshold for disk space was reached at $DISK_SPACE_ALERT%, backup was aborted." >> $BACKUP_MAIL
        mailx -s "Alert: Almost out of disk space, backups ABORTED - $usep%" $ADMIN_EMAILS < $BACKUP_MAIL
        echo "Running out of space \"$partition ($usep%)\" on $(hostname) as of $(date)"
        echo "Since threshold for disk space was reached at $DISK_SPACE_ALERT%, backup was aborted."
        exit 1
    fi
}

# Remove logs and other crap.
cleanup() {
    rm -rf $LOG_DIR/*
}

isNumber() {
    if [[ $1 = *[[:digit:]]* ]]; then
        myresult=1
    else
        myresult=0
    fi
}

main() {
        parse_config
        #cleanup
}

PID="/tmp/backup-daily.pid"
if [[ -f $PID ]]; then
    mailx -s "Daily backup process still running as of today `date +%F` on `hostname`" $ADMIN_EMAILS < $PID
    exit 1
else
    echo "This backup started on `date`" > $PID
    main &> $BACKUP_LOG
fi

NOW=`date +%F@%T`
cp $BACKUP_LOG $BACKUP_LOG.$NOW

### Mail backup and error logs ###
# Mail sent out to emails specified in column $9
# Mail also sent out to system admins specified by $ADMIN_EMAILS
report() {
    while read line
    do
        local server=`echo $line | awk -F":" '{ print $2 }'`
        local mail_list=`echo $line | awk -F":" '{ print $9 }'`
        sed -n "/=== START OF BACKUPS FOR $server ===/,/=== END OF BACKUPS FOR $server ===/p" $BACKUP_LOG > $LOG_DIR/$server-log
        if [[ -n $mail_list ]]; then
            mailx -s "Backup Log for $server `date +%F` from `hostname`" $mail_list < $LOG_DIR/$server-log
        else
            mailx -s "Backup Log for $server `date +%F` from `hostname`" $ADMIN_EMAILS < $LOG_DIR/$server-log
        fi
    done < $BACKUP_CONFIG_DAILY
    mailx -s "Backup Master Log `date +%F` from `hostname`" $ADMIN_EMAILS <  $BACKUP_LOG
}

report

### Useful server metrics sent out with each email per server and to all $ADMIN_EMAILS ###
metrics() {
    local metrics_file="$LOG_DIR/$DESTINATION-metrics"
    rm -rf $metrics_file
    echo "== Per server metrics ===" >> $metrics_file
    for file in `ls -1 $DESTINATION`
        do
            du -h --max-depth=0 $DESTINATION/$file >> $metrics_file
        done
    echo -e "\n=== Total Disk/Partition Space Usage ===" >> $metrics_file
    df -hP $DESTINATION >> $metrics_file
    mailx -s "Metrics Log `date +%F` from `hostname`" $ADMIN_EMAILS < $metrics_file
}

metrics
rm $PID
